<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Overlay Timer - TikToolStream</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700;800;900&family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --gold: #ffd700;
      --accent-primary: #00d9ff;
      --accent-secondary: #9d4edd;
      --accent-warning: #ffd23f;
      --accent-danger: #ff6b6b;
      --font-heading: 'Montserrat', sans-serif;
      --font-numeric: 'Rajdhani', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-heading);
      background: transparent;
      color: white;
      overflow: hidden;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .timer-overlay {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2rem;
      padding: 1rem;
      width: 100%;
      max-width: 900px;
    }

    /* Mascotas laterales */
    .mascot {
      width: 150px;
      height: 150px;
      flex-shrink: 0;
      animation: bounce 2s ease-in-out infinite;
    }

    .mascot img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.5));
    }

    .mascot.left {
      animation-delay: 0s;
    }

    .mascot.right {
      animation-delay: 0.5s;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    /* Timer central */
    .timer-container {
      flex: 1;
      max-width: 500px;
      background: rgba(15, 23, 42, 0.92);
      border-radius: 24px;
      padding: 2rem;
      border: 2px solid rgba(255, 215, 0, 0.3);
      backdrop-filter: blur(20px);
      box-shadow: 
        0 25px 50px -12px rgba(0, 0, 0, 0.5),
        0 0 40px rgba(255, 215, 0, 0.1);
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .timer-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-primary), var(--gold), var(--accent-secondary));
    }

    .timer-label {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--gold);
      margin-bottom: 1rem;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    .timer-display {
      font-family: var(--font-numeric);
      font-size: 6rem;
      font-weight: 700;
      line-height: 1;
      background: linear-gradient(135deg, #ffffff, var(--gold));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      filter: drop-shadow(0 4px 20px rgba(255, 215, 0, 0.3));
    }

    .timer-message {
      margin-top: 1rem;
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.8);
      min-height: 1.5em;
    }

    /* Barra de progreso */
    .progress-bar {
      margin-top: 1.5rem;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-primary), var(--gold));
      border-radius: 4px;
      transition: width 1s linear;
      width: 100%;
    }

    /* Estados de urgencia */
    .timer-container.warning {
      border-color: var(--accent-warning);
      animation: warningPulse 1s ease-in-out infinite;
    }

    .timer-container.danger {
      border-color: var(--accent-danger);
      animation: dangerPulse 0.5s ease-in-out infinite;
    }

    .timer-container.danger .timer-display {
      background: linear-gradient(135deg, #ffffff, var(--accent-danger));
      -webkit-background-clip: text;
      background-clip: text;
    }

    @keyframes warningPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 210, 63, 0.3); }
      50% { box-shadow: 0 0 40px rgba(255, 210, 63, 0.5); }
    }

    @keyframes dangerPulse {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.4); }
      50% { box-shadow: 0 0 50px rgba(255, 107, 107, 0.7); }
    }

    /* Logo */
    .timer-logo {
      position: absolute;
      bottom: 10px;
      right: 15px;
      width: 40px;
      opacity: 0.5;
    }

    /* Conectando */
    .connecting {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      text-align: center;
    }

    .connecting-text {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.8);
      margin-top: 1rem;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Ganador */
    .winner-display {
      display: none;
      margin-top: 1rem;
      padding: 0.75rem 1.5rem;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.05));
      border: 2px solid var(--gold);
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--gold);
      animation: goldGlow 2s ease-in-out infinite;
    }

    @keyframes goldGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
      50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.6); }
    }

    /* Panel de configuraci√≥n */
    .config-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(255, 215, 0, 0.2);
      border: 1px solid var(--gold);
      color: var(--gold);
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      transition: all 0.3s;
      z-index: 100;
    }

    .config-toggle:hover {
      background: rgba(255, 215, 0, 0.4);
    }

    .config-panel {
      position: fixed;
      top: 50px;
      right: 10px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      padding: 20px;
      width: 280px;
      z-index: 100;
      display: none;
      backdrop-filter: blur(10px);
    }

    .config-panel.active {
      display: block;
    }

    .config-title {
      color: var(--gold);
      font-size: 1rem;
      margin-bottom: 15px;
      font-weight: 700;
    }

    .config-group {
      margin-bottom: 15px;
    }

    .config-group label {
      display: block;
      font-size: 0.85rem;
      color: rgba(255,255,255,0.7);
      margin-bottom: 6px;
    }

    .config-preview {
      width: 60px;
      height: 60px;
      object-fit: contain;
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      margin-bottom: 8px;
    }

    .config-file {
      width: 100%;
      font-size: 0.85rem;
      color: rgba(255,255,255,0.7);
    }

    .config-file::file-selector-button {
      background: rgba(255, 215, 0, 0.2);
      border: 1px solid var(--gold);
      color: var(--gold);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8rem;
      margin-right: 10px;
    }

    .config-btn {
      width: 100%;
      background: linear-gradient(135deg, var(--gold), #ffa500);
      border: none;
      color: #000;
      padding: 10px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.9rem;
      margin-top: 10px;
    }

    .config-btn:hover {
      opacity: 0.9;
    }

    .config-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .config-status {
      font-size: 0.8rem;
      margin-top: 10px;
      text-align: center;
      min-height: 1.2em;
    }

    .config-status.success { color: #2ed573; }
    .config-status.error { color: #ff6b6b; }
  </style>
</head>
<body>
  <!-- Bot√≥n para mostrar/ocultar configuraci√≥n -->
  <button class="config-toggle" id="configToggle">‚öôÔ∏è Personalizar</button>
  
  <!-- Panel de configuraci√≥n -->
  <div class="config-panel" id="configPanel">
    <div class="config-title">üé® Personalizar Mascotas</div>
    
    <div class="config-group">
      <label>Mascota Izquierda</label>
      <img id="leftPreview" class="config-preview" src="assets/QuesadillaCrocodilla.webp">
      <input type="file" id="leftImageInput" class="config-file" accept="image/*">
    </div>
    
    <div class="config-group">
      <label>Mascota Derecha</label>
      <img id="rightPreview" class="config-preview" src="assets/Noel.webp">
      <input type="file" id="rightImageInput" class="config-file" accept="image/*">
    </div>
    
    <button class="config-btn" id="saveImagesBtn">üíæ Guardar Cambios</button>
    <div class="config-status" id="configStatus"></div>
  </div>

  <div id="connectingScreen" class="connecting">
    <div class="spinner"></div>
    <p class="connecting-text">Conectando con el panel...</p>
  </div>

  <div id="timerOverlay" class="timer-overlay" style="display: none;">
    <!-- Mascota Izquierda -->
    <div class="mascot left">
      <img id="mascotLeft" src="assets/QuesadillaCrocodilla.webp" alt="Mascota">
    </div>

    <!-- Timer Central -->
    <div class="timer-container" id="timerContainer">
      <h2 class="timer-label" id="timerLabel">MIN 10</h2>
      <div class="timer-display" id="timerDisplay">02:00</div>
      <div class="timer-message" id="timerMessage"></div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="winner-display" id="winnerDisplay">
        üèÜ GANADOR: <span id="winnerName">‚Äî</span>
      </div>
      <img src="assets/LOGOSINFONDO.png" alt="Logo" class="timer-logo">
    </div>

    <!-- Mascota Derecha -->
    <div class="mascot right">
      <img id="mascotRight" src="assets/Noel.webp" alt="Mascota">
    </div>
  </div>

  <script>
    // Conexi√≥n con el panel principal via BroadcastChannel
    const channel = new BroadcastChannel('tiktoolstream_overlay');
    const connectingScreen = document.getElementById('connectingScreen');
    const timerOverlay = document.getElementById('timerOverlay');
    const timerDisplay = document.getElementById('timerDisplay');
    const timerLabel = document.getElementById('timerLabel');
    const timerMessage = document.getElementById('timerMessage');
    const timerContainer = document.getElementById('timerContainer');
    const progressFill = document.getElementById('progressFill');
    const winnerDisplay = document.getElementById('winnerDisplay');
    const winnerName = document.getElementById('winnerName');
    const mascotLeft = document.getElementById('mascotLeft');
    const mascotRight = document.getElementById('mascotRight');

    let initialTime = 120;
    let connected = false;
    let connectionAttempts = 0;
    const MAX_CONNECTION_ATTEMPTS = 3;

    // Funci√≥n para intentar conexi√≥n
    function attemptConnection() {
      connectionAttempts++;
      console.log(`[OVERLAY] Intento de conexi√≥n ${connectionAttempts}/${MAX_CONNECTION_ATTEMPTS}`);
      
      // Solicitar datos iniciales
      channel.postMessage({ type: 'request_sync', timestamp: Date.now() });
      
      // Si no hay respuesta en 2 segundos, verificar modo independiente
      setTimeout(() => {
        if (!connected) {
          checkIndependentMode();
        }
      }, 2000);
    }

    // Funci√≥n para verificar modo independiente
    function checkIndependentMode() {
      const token = getToken();
      if (token) {
        console.log('[OVERLAY] Activando modo independiente con token v√°lido');
        activateIndependentMode();
      } else if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
        console.log('[OVERLAY] Sin token v√°lido, reintentando conexi√≥n...');
        setTimeout(attemptConnection, 1000);
      } else {
        console.log('[OVERLAY] No se puede establecer conexi√≥n ni modo independiente');
        showConnectionError();
      }
    }

    // Funci√≥n para activar modo independiente
    function activateIndependentMode() {
      connected = 'independent'; // Marcar como conectado en modo independiente
      connectingScreen.style.display = 'none';
      timerOverlay.style.display = 'flex';
      timerDisplay.textContent = '00:00';
      timerLabel.textContent = 'Modo Independiente';
      loadSavedImages();
    }

    // Funci√≥n para mostrar error de conexi√≥n
    function showConnectionError() {
      connectingScreen.innerHTML = `
        <p class="connecting-text">‚ö†Ô∏è No se detect√≥ el panel principal</p>
        <p class="connecting-text" style="font-size: 0.9rem; opacity: 0.7;">
          Abre desde el panel de control para funcionar correctamente
        </p>
        <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #fe2c55; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;">
          üîÑ Reintentar
        </button>
      `;
    }

    // Iniciar primer intento de conexi√≥n
    attemptConnection();

    // Escuchar actualizaciones
    channel.onmessage = (event) => {
      const data = event.data;
      
      if (!connected && data.type !== 'error') {
        connected = true;
        connectingScreen.style.display = 'none';
        timerOverlay.style.display = 'flex';
        console.log('[OVERLAY] Conectado con panel principal');
      }

      switch (data.type) {
        case 'timer_update':
          updateTimer(data);
          break;
        case 'timer_config':
          if (data.initialTime) initialTime = data.initialTime;
          if (data.label) timerLabel.textContent = data.label;
          break;
        case 'winner':
          showWinner(data.winner);
          break;
        case 'overlay_images':
          if (data.leftImage) mascotLeft.src = data.leftImage;
          if (data.rightImage) mascotRight.src = data.rightImage;
          break;
        case 'sync':
          // Sincronizaci√≥n completa
          if (data.timer) updateTimer(data.timer);
          if (data.config) {
            initialTime = data.config.initialTime || 120;
            timerLabel.textContent = data.config.label || 'MIN 10';
          }
          if (data.images) {
            if (data.images.left) mascotLeft.src = data.images.left;
            if (data.images.right) mascotRight.src = data.images.right;
          }
          break;
      }
    };

    function updateTimer(data) {
      const seconds = data.seconds || 0;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

      // Actualizar barra de progreso
      const progress = (seconds / initialTime) * 100;
      progressFill.style.width = `${Math.max(0, Math.min(100, progress))}%`;

      // Estados de urgencia
      timerContainer.classList.remove('warning', 'danger');
      if (seconds <= 10) {
        timerContainer.classList.add('danger');
      } else if (seconds <= 30) {
        timerContainer.classList.add('warning');
      }

      // Mensaje
      if (data.message) {
        timerMessage.textContent = data.message;
      }

      // Ocultar ganador si el timer est√° activo
      if (seconds > 0) {
        winnerDisplay.style.display = 'none';
      }
    }

    function showWinner(winner) {
      if (winner) {
        winnerName.textContent = winner;
        winnerDisplay.style.display = 'block';
      }
    }


    // Mantener viva la conexi√≥n
    setInterval(() => {
      if (connected) {
        channel.postMessage({ type: 'ping' });
      }
    }, 10000);

    // ========== CONFIGURACI√ìN DE IM√ÅGENES ==========
    const configToggle = document.getElementById('configToggle');
    const configPanel = document.getElementById('configPanel');
    const leftPreview = document.getElementById('leftPreview');
    const rightPreview = document.getElementById('rightPreview');
    const leftImageInput = document.getElementById('leftImageInput');
    const rightImageInput = document.getElementById('rightImageInput');
    const saveImagesBtn = document.getElementById('saveImagesBtn');
    const configStatus = document.getElementById('configStatus');

    // Toggle panel
    configToggle.addEventListener('click', () => {
      configPanel.classList.toggle('active');
    });

    // Preview de im√°genes
    leftImageInput.addEventListener('change', (e) => {
      if (e.target.files[0]) {
        leftPreview.src = URL.createObjectURL(e.target.files[0]);
      }
    });

    rightImageInput.addEventListener('change', (e) => {
      if (e.target.files[0]) {
        rightPreview.src = URL.createObjectURL(e.target.files[0]);
      }
    });

    // Obtener token (desde URL o localStorage)
    function getToken() {
      // Primero intentar obtener de la URL (pasado desde el panel principal)
      const urlParams = new URLSearchParams(window.location.search);
      const urlToken = urlParams.get('token');
      if (urlToken) {
        // Verificar si el token es v√°lido antes de usarlo
        try {
          const payload = JSON.parse(atob(urlToken.split('.')[1]));
          const now = Math.floor(Date.now() / 1000);
          if (payload.exp > now) {
            // Token v√°lido, guardarlo
            localStorage.setItem('accessToken', urlToken);
            return urlToken;
          } else {
            console.log('Token de URL expirado');
          }
        } catch (e) {
          console.log('Token de URL inv√°lido');
        }
      }
      
      // Fallback a localStorage/sessionStorage
      const storedToken = localStorage.getItem('accessToken') || sessionStorage.getItem('accessToken');
      if (storedToken) {
        try {
          const payload = JSON.parse(atob(storedToken.split('.')[1]));
          const now = Math.floor(Date.now() / 1000);
          if (payload.exp > now) {
            return storedToken;
          } else {
            console.log('Token almacenado expirado');
            localStorage.removeItem('accessToken');
            sessionStorage.removeItem('accessToken');
          }
        } catch (e) {
          console.log('Token almacenado inv√°lido');
          localStorage.removeItem('accessToken');
          sessionStorage.removeItem('accessToken');
        }
      }
      
      return null;
    }

    // Funci√≥n para refrescar token
    async function refreshToken() {
      const refreshToken = localStorage.getItem('refreshToken');
      if (!refreshToken) return null;

      try {
        const response = await fetch('/api/auth/refresh', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ refreshToken })
        });

        if (response.ok) {
          const data = await response.json();
          localStorage.setItem('accessToken', data.accessToken);
          localStorage.setItem('refreshToken', data.refreshToken);
          return data.accessToken;
        } else {
          // Refresh token tambi√©n expirado
          localStorage.removeItem('accessToken');
          localStorage.removeItem('refreshToken');
          sessionStorage.removeItem('accessToken');
          sessionStorage.removeItem('refreshToken');
          return null;
        }
      } catch (error) {
        console.error('Error refreshing token:', error);
        return null;
      }
    }

    // Funci√≥n mejorada para hacer requests con auto-refresh
    async function apiCall(url, options = {}) {
      let token = getToken();
      
      // Si no hay token v√°lido, intentar refresh
      if (!token) {
        token = await refreshToken();
        if (!token) {
          throw new Error('No hay token v√°lido');
        }
      }

      const response = await fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        }
      });

      // Si es 401, intentar refresh una vez
      if (response.status === 401) {
        const newToken = await refreshToken();
        if (newToken) {
          // Reintentar con nuevo token
          return fetch(url, {
            ...options,
            headers: {
              ...options.headers,
              'Authorization': `Bearer ${newToken}`
            }
          });
        }
      }

      return response;
    }

    // Cargar im√°genes guardadas del usuario
    async function loadSavedImages() {
      try {
        const response = await apiCall('/api/overlays/my');
        
        if (response.ok) {
          const data = await response.json();
          if (data.left_image_url) {
            mascotLeft.src = data.left_image_url;
            leftPreview.src = data.left_image_url;
          }
          if (data.right_image_url) {
            mascotRight.src = data.right_image_url;
            rightPreview.src = data.right_image_url;
          }
        } else {
          console.error('Error response loading images:', response.status, response.statusText);
          if (response.status === 401) {
            console.log('Token expired or invalid, user needs to login again');
          }
        }
      } catch (error) {
        console.error('Error loading saved images:', error);
        if (error.message.includes('No hay token v√°lido')) {
          configStatus.textContent = '‚ö†Ô∏è Sesi√≥n expirada. Cierra y abre de nuevo desde el panel principal.';
          configStatus.className = 'config-status error';
        }
      }
    }

    // Guardar im√°genes
    saveImagesBtn.addEventListener('click', async () => {
      const formData = new FormData();
      if (leftImageInput.files[0]) {
        formData.append('leftImage', leftImageInput.files[0]);
      }
      if (rightImageInput.files[0]) {
        formData.append('rightImage', rightImageInput.files[0]);
      }

      if (!leftImageInput.files[0] && !rightImageInput.files[0]) {
        configStatus.textContent = 'Selecciona al menos una imagen';
        configStatus.className = 'config-status error';
        return;
      }

      saveImagesBtn.disabled = true;
      saveImagesBtn.textContent = 'Guardando...';
      configStatus.textContent = '';

      try {
        const response = await apiCall('/api/overlays', {
          method: 'POST',
          body: formData
        });

        if (response.ok) {
          const data = await response.json();
          
          // Actualizar mascotas en el overlay
          if (data.left_image_url) {
            mascotLeft.src = data.left_image_url;
            leftPreview.src = data.left_image_url;
          }
          if (data.right_image_url) {
            mascotRight.src = data.right_image_url;
            rightPreview.src = data.right_image_url;
          }

          // Notificar al panel principal
          channel.postMessage({
            type: 'overlay_images_updated',
            leftImage: data.left_image_url,
            rightImage: data.right_image_url
          });

          configStatus.textContent = '‚úÖ Guardado exitosamente';
          configStatus.className = 'config-status success';
          
          // Limpiar inputs
          leftImageInput.value = '';
          rightImageInput.value = '';
        } else {
          console.error('Error response saving images:', response.status, response.statusText);
          const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
          if (response.status === 401) {
            throw new Error('Sesi√≥n expirada. Cierra y abre de nuevo desde el panel principal.');
          }
          throw new Error(errorData.error || `Error ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        console.error('Error saving images:', error);
        configStatus.textContent = '‚ùå Error: ' + error.message;
        configStatus.className = 'config-status error';
        
        if (error.message.includes('No hay token v√°lido') || error.message.includes('Sesi√≥n expirada')) {
          setTimeout(() => {
            configStatus.textContent = 'üîÑ Intenta cerrar y abrir de nuevo desde el panel principal';
          }, 3000);
        }
      } finally {
        saveImagesBtn.disabled = false;
        saveImagesBtn.textContent = 'üíæ Guardar Cambios';
      }
    });

    // Cargar im√°genes al iniciar
    loadSavedImages();
  </script>
</body>
</html>
